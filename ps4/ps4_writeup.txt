Owen Derby
6.945 PS4

Code at https://github.com/oderby/6.945/tree/master/ps4/code

Problem 4.1: The code in ps4_demo.scm demonstrates that my implementation works
	for the specified cases of (lambda x (...)) and (define (ss . x)
	(...)). (it als doesn't break anything). However, it currently doesn't
	support the case of (lambda (x y . z) (...)) or (define (ss x y . z)
	(...))

Problem 4.2: Again, ps4_demo.scm demonstrates what I got working. However, I
	currently don't support unary operations such as sqrt(..), nor do I
	support parenthesis. Support for these would require incorporating a
	mechanism for scanning over parenthetical expressions when tokenizing on
	the various operators (as opposed to currently, when I just look for the
	next appearance of the given operator during tokenization). Given
	support for parenthesis, unary support just requires looking for
	non-arithmetic operator prefixes to parenthetical expressions.

Problem 4.3

Note - I could not easily run the multiple-dwelling problem as it was
provided. You can see the changes I needed to make in order to get it just to
run in the diffs.

Ex 4.38: There are 5 solutions to the modified puzzle

Ex 4.39: Reordering the require statments shouldn't make too much of a
   difference. A failed require statment will force a backtrack. Since all the
   require statements appear sequentially afterall variables have been assigned
   a value, failing an earlier require statement would save us from evaluating
   the conditionals in the later require statements. So if there is a particular
   requirement statement which will fail the most times in this evaluation, then
   we might save some time by putting that first. However, that is already the
   case, since our requirement that all assignments be unique is the first
   requirement. After that, we could put the requirements between pairs of
   variables earlier, but the expected time difference in this case would be
   negligible, not to mention that the additional computation in those may
   outweigh the benefit of putting them earlier.

Ex 4.40 There are 5^5=3125 assignments without the requirement that they be
   distinct. With the distinct requirement, there are 5!=120 assignments. See
   diff for the new procedure.


Problem 4.4

Ex 4.50: See ps4_demo.scm for demo code. With undoable set, count is always 1,
   because the assignment is always undone after we backtrack to the next choice
   point.

Ex 4.51: This will simply append every single pair of integers examined to the
   variable 'pairs. So when this is finished, it will be a list of every single
   pair of values generated by taking an element from each list. ie ((1 20) (3
   20)...(8 20) (1 35)...(8 110))
